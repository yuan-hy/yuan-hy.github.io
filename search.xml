<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis</title>
      <link href="/2022/09/13/redis/"/>
      <url>/2022/09/13/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-redis"><a href="#什么是-redis" class="headerlink" title="什么是 redis"></a>什么是 redis</h2><blockquote><p>官网 ： <a href="https://redis.io/">https://redis.io/</a></p></blockquote><h3 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h3><ul><li>数百万开发人员用作<code>数据库</code>、<code>缓存</code>、<code>流引擎</code>和<code>消息代理</code>的开源<code>内存数据存储</code></li></ul><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><ul><li>内存数据结构<ul><li>众所周知的“数据结构服务器”，支持字符串、哈希、列表、集合、排序集合、流等。</li><li><a href="https://redis.io/docs/data-types/">具体查看</a></li></ul></li><li>可编程的<ul><li>使用 Lua 的服务器端脚本和使用 Redis 函数的服务器端存储过程</li><li><a href="https://redis.io/docs/manual/programmability/">具体查看</a></li></ul></li><li>可扩展性<ul><li>用于在 C、C++ 和 Rust 中构建 Redis 自定义扩展的模块 API</li><li><a href="https://redis.io/docs/reference/modules/">具体查看</a></li></ul></li><li>持久性<ul><li>将数据集保存在内存中以便快速访问，但也可以将所有写入持久存储到永久存储中，以在重新启动和系统故障后继续存在。</li><li><a href="https://redis.io/docs/manual/persistence/">具体查看</a></li></ul></li><li>集群<ul><li>通过基于哈希的分片实现水平可扩展性，在集群增长时通过自动重新分区扩展到数百万个节点。</li><li><a href="https://redis.io/docs/manual/scaling/">具体查看</a></li></ul></li><li>高可用性<ul><li>用于独立和集群部署的自动故障转移复制</li><li><a href="https://redis.io/docs/manual/replication/">具体查看</a></li></ul></li></ul><h3 id="官方推荐使用场景"><a href="#官方推荐使用场景" class="headerlink" title="官方推荐使用场景"></a>官方推荐使用场景</h3><ul><li>实时数据存储(Real-time data store)<ul><li>Redis 的<code>多功能内存数据结构</code>能够为需要<code>低延迟</code>和<code>高吞吐量</code>的实时应用程序构建数据基础架构。</li></ul></li><li>缓存和会话存储(Caching &amp; session storage)<ul><li>Redis 的速度使其成为缓存数据库查询、复杂计算、API 调用和会话状态的理想选择</li></ul></li><li>流媒体和消息队列<ul><li>流数据类型支持高速数据摄取、消息传递、事件溯源和通知。</li></ul></li></ul><ol start="4"><li><h3 id="Redis-堆栈"><a href="#Redis-堆栈" class="headerlink" title="Redis 堆栈"></a>Redis 堆栈</h3></li></ol><ul><li>Redis Stack 使用现代数据模型和处理引擎扩展了 Redis，以提供完整的开发人员体验。下载源代码，使用您最喜欢的包管理器安装，或在云中免费启动它。<ul><li>Redis Stack Server 允许您使用可搜索的 JSON、时间序列和图形数据模型以及扩展的概率数据结构来构建应用程序</li><li>使用 Redis Stack 对象映射和客户端库快速提高工作效率。</li><li>使用 RedisInsight 可视化和优化您的 Redis 数据。</li></ul></li><li><a href="https://redis.io/download/">下载 redis 堆栈</a></li><li><a href="https://redis.io/docs/stack/">具体查看更多关于堆栈</a></li><li>Redis 堆栈用例<ul><li>可搜索的 Redis<ul><li>索引和查询 Redis 数据结构和数据模型；对您的 Redis 数据运行复杂的聚合和全文搜索。</li></ul></li><li>文档数据库<ul><li>完全在 Redis 中对域进行建模，并有效地查询您的 JSON 数据，而无需使用缓存。</li></ul></li><li>遥测<ul><li>从现场设备中获取连续读数，将其存储为时间序列数据或使用概率数据结构进行分析和重复数据删除</li></ul></li><li>身份和资源管理<ul><li>将数字资源和 ACL 定义为图形，并使用单个 Cypher 查询实时计算权限。</li></ul></li><li>向量相似度搜索<ul><li>查询向量嵌入以支持图像搜索、推荐引擎和自然语言文本处理。</li></ul></li><li>欺诈识别<ul><li>实时检测欺诈的所有工具，包括图形分析、概率查询、向量搜索，甚至使用流进行处理。</li></ul></li></ul></li></ul><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="安装启动-Redis-Server"><a href="#安装启动-Redis-Server" class="headerlink" title="安装启动 Redis Server"></a>安装启动 <code>Redis Server</code></h3><ul><li><p>在 <a href="https://redis.io/docs/getting-started/installation/install-redis-on-linux/">Linux</a> 上安装</p></li><li><p>在 <a href="https://redis.io/docs/getting-started/installation/install-redis-on-mac-os/">macOS</a> 上安装</p><ul><li><p><input checked="" disabled="" type="checkbox">  当前使用 macOS</p><ul><li><p>在 macOS 上使用 Homebrew 安装和启动 Redis</p><ol><li><strong>首先执行以下命令查看安装了 Homebrew</strong></li></ol><pre class=" language-bash"><code class="language-bash">$ brew --version  Homebrew 3.4.9  Homebrew/homebrew-core <span class="token punctuation">(</span>git revision ca10e12c01f<span class="token punctuation">;</span> last commit 2022-05-01<span class="token punctuation">)</span></code></pre><p>  如果此命令失败，您需要按照 <a href="https://brew.sh/">Homebrew 安装说明</a> 进行操作。</p><ol start="2"><li><strong>执行以下命令安装 Redis</strong></li></ol><pre class=" language-bash"><code class="language-bash">$ brew <span class="token function">install</span> redis</code></pre><p>  一般没什么问题就在系统上安装了 Redis</p><ol start="3"><li><strong>前台启动和停止 Redis Server</strong></li></ol><ul><li>启动</li></ul><pre class=" language-bash"><code class="language-bash">$ redis-server</code></pre><p>  如果成功，您将看到 Redis 的启动日志，并且 Redis 将在前台运行。</p><ul><li>停止<ul><li>直接 Ctrl-C 退出</li></ul></li></ul><ol start="4"><li><strong>后台启动和停止 Redis Server</strong></li></ol><ul><li>启动</li></ul><pre class=" language-bash"><code class="language-bash">$ brew services start redis<span class="token operator">==</span><span class="token operator">></span> Successfully started <span class="token variable"><span class="token variable">`</span>redis<span class="token variable">`</span></span> <span class="token punctuation">(</span>label: homebrew.mxcl.redis<span class="token punctuation">)</span></code></pre><ul><li>运行以下命令检查托管 Redis 的状态</li></ul><pre class=" language-bash"><code class="language-bash">$ brew services info redisredis <span class="token punctuation">(</span>homebrew.mxcl.redis<span class="token punctuation">)</span>Running: ✔Loaded: ✔Schedulable: ✘User: overdosePID: 64176</code></pre><ul><li>停止</li></ul><pre class=" language-bash"><code class="language-bash">$ brew services stop redisStopping <span class="token variable"><span class="token variable">`</span>redis<span class="token variable">`</span></span><span class="token punctuation">..</span>. <span class="token punctuation">(</span>might take a while<span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">></span> Successfully stopped <span class="token variable"><span class="token variable">`</span>redis<span class="token variable">`</span></span> <span class="token punctuation">(</span>label: homebrew.mxcl.redis<span class="token punctuation">)</span></code></pre><ol start="5"><li>redis-cli 连接 redis-server</li></ol><pre class=" language-bash"><code class="language-bash">$ redis-cli</code></pre><p>  因为在本地，所以不需要其他像 host 参数连接，具体使用哪些参数，可以执行 redis-cli –help</p><p>  如 ： </p><pre class=" language-bash"><code class="language-bash">$ redis-cli -h 127.0.0.1 -p 6379 -a rediscli-auth --user username --pass password 等</code></pre><p>  测试</p><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> lpush demos redis-macOS-demoOK127.0.0.1:6379<span class="token operator">></span> rpop demos<span class="token string">"redis-macOS-demo"</span></code></pre></li></ul></li></ul></li><li><p>在 <a href="https://redis.io/docs/getting-started/installation/install-redis-on-windows/">Windows</a> 上安装</p></li></ul><h2 id="Redis-CLI"><a href="#Redis-CLI" class="headerlink" title="Redis CLI"></a>Redis CLI</h2><h3 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h3><ul><li>redis command line interface(redis-cli) 意思是 redis 命令行界面</li><li>用于向 Redis 服务器发送命令和读取来自 Redis 服务器的回复</li><li>有以下两种模式<ul><li>交互模式：交互式读取评估打印循环 (REPL) 模式<ul><li>用户键入 Redis 命令并接收回复,以下是通过 redis-cli 连接进入交互模式，连接之后直接输入命令就可以，无需带上 redis-cli</li></ul><pre class=" language-bash"><code class="language-bash">$ redis-cli127.0.0.1:6379<span class="token operator">></span>  </code></pre></li><li>参数模式：redis-cli 使用附加参数执行并将回复打印到标准输出的命令模式。该模式下不会进入交互模式，直接 <code>redis-cli 命令 命令参数</code> 执行<pre class=" language-bash"><code class="language-bash">$ redis-cli INCR mycounter<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1$ redis-cli INCR mycounter<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2</code></pre>两个模式都是可以切换使用的,以下为从参数模式切换到交互模式<pre class=" language-bash"><code class="language-bash">$ redis-cli               127.0.0.1:6379<span class="token operator">></span> INCR mycounter<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3127.0.0.1:6379<span class="token operator">></span></code></pre><ul><li>redis-cli 可以使用一些选项来启动程序，以使其进入特殊模式，以完成更复杂的任务<ul><li>模拟从服务器并打印从主服务器接收的复制流</li><li>检查Redis的延迟并打印统计数据</li><li>显示延迟样本和频率以及其他许多东西的ASCII图</li></ul></li></ul></li></ul></li></ul><h3 id="命令行用法"><a href="#命令行用法" class="headerlink" title="命令行用法"></a>命令行用法</h3><h4 id="命令的返回值和类型"><a href="#命令的返回值和类型" class="headerlink" title="命令的返回值和类型"></a>命令的返回值和类型</h4><pre class=" language-bash"><code class="language-bash">  $ redis-cli INCR mycounter  <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4</code></pre><p>回复值为 4 ，类型是括号里的 integer, redis 是类型化的，包括 strings, arrays, integers, nil, errors 等等</p><h4 id="重定向输出到文件中"><a href="#重定向输出到文件中" class="headerlink" title="重定向输出到文件中"></a>重定向输出到文件中</h4><p>redis-cli仅在检测到标准输出是 tty 或终端时才显示附加信息以供人类阅读。对于所有其他输出，它将自动启用原始输出模式，如下例所示</p><pre class=" language-bash"><code class="language-bash">  $ redis-cli INCR mycounter <span class="token operator">></span> /Users/overdose/IdeaProjects/springboot-demo/redis/redis-result.txt  $ <span class="token function">cat</span> redis/redis-result.txt  5</code></pre><p>强制不使用原始输出模式可以加 –no-raw ,否则也可以使用显示原始输出 –raw</p><pre class=" language-bash"><code class="language-bash">  $ redis-cli --no-raw INCR mycounter <span class="token operator">></span> /Users/overdose/IdeaProjects/springboot-demo/redis/redis-result.txt  $ <span class="token function">cat</span> redis/redis-result.txt  <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6</code></pre><h4 id="字符串引用和转义"><a href="#字符串引用和转义" class="headerlink" title="字符串引用和转义"></a>字符串引用和转义</h4><ul><li>空格字符会自动分隔参数,字符串使用 “” ,支持转义字符</li></ul><pre class=" language-bash"><code class="language-bash">\<span class="token string">"- 双引号\n- 换行\r- 回车\t- 水平选项卡\b- 退格\a- 警报\\- 反斜杠\xhh- 任何由十六进制数 ( hh )表示的 ASCII 字符单引号假定字符串是文字，并且只允许以下转义序列：\'- 单引号\\- 反斜杠127.0.0.1:6379> SET mykey "</span>Hello\nWorld<span class="token string">"OK127.0.0.1:6379> GET mykeyHelloWorld例如，当您输入包含单引号或双引号的字符串时，例如在密码中可能会转义字符串，如下所示：127.0.0.1:6379> AUTH some_admin_user "</span><span class="token operator">></span>^8T<span class="token operator">></span>6Na<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;u|jp>+v\"55\@_;OU(OR]7mbAYGqsfyu48(j'%hQH7;v*f1H$&amp;#123;*gD(Se'"</span></code></pre><h4 id="主机、端口、密码和数据库"><a href="#主机、端口、密码和数据库" class="headerlink" title="主机、端口、密码和数据库"></a>主机、端口、密码和数据库</h4><ul><li>默认通过 ip = 127.0.0.1 ,port = 6379 连接 redis server 实例,甚至可以通过 -h 指定 ip,-p 指定端口连接</li></ul><pre class=" language-bash"><code class="language-bash">  $ redis-cli -h 127.0.0.1 -p 6379 PING  PONG</code></pre><p>如果实例受密码保护，该-a <password>选项将执行身份验证，无需显式使用以下AUTH命令</p><pre class=" language-bash"><code class="language-bash">  $ redis-cli -a myUnguessablePazzzzzword123 PING  PONG</code></pre><p>出于安全考虑，建议使用 REDISCLI_AUTH 配置认证</p><p>如果不清楚可以查看一下流程步骤查看以及配置密码</p><ul><li>查看是否配置密码</li></ul><pre class=" language-bash"><code class="language-bash">  $ redis-cli config get requirepass  1<span class="token punctuation">)</span> <span class="token string">"requirepass"</span>  2<span class="token punctuation">)</span> <span class="token string">""</span></code></pre><p>以上结果表示还没设置密码，如果设置了密码会出现如下结果</p><pre class=" language-bash"><code class="language-bash">  $ redis-cli config get requirepass         <span class="token punctuation">(</span>error<span class="token punctuation">)</span> NOAUTH Authentication required.</code></pre><ul><li><p>设置密码</p><ul><li>临时性设置(命令配置)， redis 重启后失效</li></ul><pre class=" language-bash"><code class="language-bash">    $ redis-cli config <span class="token keyword">set</span> requirepass 123456    OK</code></pre><pre><code>123456 表示你要设置的密码  </code></pre><ul><li>永久性设置(redis.conf 文件配置), redis 重启后不失效</li></ul><p>在 redis.conf 配置文件中找到 requirepass 这个参数，如下配置：</p><p>修改redis.conf配置文件</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># requirepass foobared</span>requirepass 123456   <span class="token comment" spellcheck="true"># 指定密码123456</span></code></pre><p>保存后重启 redis 就可以了</p><ul><li>连接验证<ul><li>通过命令 <code>auth password</code> 验证<ul><li>验证前</li></ul><pre class=" language-bash"><code class="language-bash">$ redis-cli get key<span class="token punctuation">(</span>error<span class="token punctuation">)</span> NOAUTH Authentication required.</code></pre><ul><li>验证后</li></ul>不建议直接通过 <code>-a password</code> 在命令行上输入明文密码，会有如下提示<pre class=" language-bash"><code class="language-bash">  $ redis-cli -a 123456 get key  Warning: Using a password with <span class="token string">'-a'</span> or <span class="token string">'-u'</span> option on the <span class="token function">command</span> line interface may not be safe.  <span class="token punctuation">(</span>nil<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 因为 key 没有 value 值，返回类型 nil</span></code></pre><ul><li>建议先登录，再通过 <code>auth password</code></li></ul><pre class=" language-bash"><code class="language-bash">$ redis-cli127.0.0.1:6379<span class="token operator">></span> get key<span class="token punctuation">(</span>error<span class="token punctuation">)</span> NOAUTH Authentication required.127.0.0.1:6379<span class="token operator">></span> auth 123456OK127.0.0.1:6379<span class="token operator">></span> get key<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>127.0.0.1:6379<span class="token operator">></span></code></pre></li></ul></li></ul></li><li><p>连接指定的数据库</p><ul><li>redis 总共有 16 个数据库，默认使用的是 0 数据库 ，因此默认连接 0 数据库，不显示数据库索引</li></ul><pre class=" language-bash"><code class="language-bash">$ redis-cli127.0.0.1:6379<span class="token operator">></span> auth 123456OK127.0.0.1:6379<span class="token operator">></span></code></pre><ul><li>通过 <code>select index</code> 切换到对应第 index+1 个数据库(索引从 0 开始)</li></ul><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">select</span> 3 <span class="token comment" spellcheck="true"># 切换到索引为 3 的数据库，也就是第 4 个数据库</span>OK127.0.0.1:6379<span class="token punctuation">[</span>3<span class="token punctuation">]</span><span class="token operator">></span> 127.0.0.1:6379<span class="token punctuation">[</span>3<span class="token punctuation">]</span><span class="token operator">></span> <span class="token keyword">select</span> 16 <span class="token comment" spellcheck="true"># 总共只有 16 个数据库，索引只支持到 15</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR DB index is out of range127.0.0.1:6379<span class="token punctuation">[</span>3<span class="token punctuation">]</span><span class="token operator">></span></code></pre><ul><li>也可以通过 <code>-n index</code> 指定数据库</li></ul><pre class=" language-bash"><code class="language-bash">$ redis-cli -n 1 <span class="token comment" spellcheck="true"># 连接到 index=1 数据库</span>$ redis-cli -n 1 SELECT 1 failed: NOAUTH Authentication required.127.0.0.1:6379<span class="token operator">></span> auth 123456OK127.0.0.1:6379<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">></span></code></pre><ul><li>各个数据库保存的数据互不影响，其他数据库看不到<ul><li>在 index=1 和 index=2 的数据库分别设置 key=key1 的键值对，互相获取对方的 key ,获取的是在本数据库设置的值，都无法获取对方数据库设置的值</li></ul><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">></span> <span class="token keyword">set</span> key1 123OK127.0.0.1:6379<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">></span> <span class="token keyword">select</span> 2OK127.0.0.1:6379<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token operator">></span> get key1<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>127.0.0.1:6379<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token operator">></span> <span class="token keyword">set</span> key1 234OK127.0.0.1:6379<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token operator">></span> get key1<span class="token string">"234"</span>127.0.0.1:6379<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token operator">></span> <span class="token keyword">select</span> 1OK127.0.0.1:6379<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">></span> get key1<span class="token string">"123"</span>127.0.0.1:6379<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">></span> </code></pre></li><li>flushdb 清除当前所在数据库的所有数据，对其他数据库的数据不影响<ul><li>执行 flushdb 清除索引为 1 的数据库，查看索引为 1 和 2 数据库的数据</li></ul><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">></span> flushdbOK127.0.0.1:6379<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">></span> keys *<span class="token punctuation">(</span>empty array<span class="token punctuation">)</span>127.0.0.1:6379<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">></span> get key1<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>127.0.0.1:6379<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">></span> <span class="token keyword">select</span> 2 <span class="token comment" spellcheck="true"># 切换到 2 数据库查看</span>OK127.0.0.1:6379<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token operator">></span> keys *1<span class="token punctuation">)</span> <span class="token string">"key1"</span>127.0.0.1:6379<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token operator">></span> get key1<span class="token string">"234"</span>127.0.0.1:6379<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token operator">></span></code></pre></li><li>flushall 清除 redis 服务起的所有数据库的数据<ul><li>执行 flushall 之后查看 1 和 2 数据库的数据是否存在</li></ul><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token operator">></span> <span class="token keyword">select</span> 1 <span class="token comment" spellcheck="true"># 先切换回 1 数据库添加数据</span>OK127.0.0.1:6379<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">></span> <span class="token keyword">set</span> key1 123OK127.0.0.1:6379<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">></span> get key1<span class="token string">"123"</span>127.0.0.1:6379<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">></span> flushall <span class="token comment" spellcheck="true"># 清除所有数据库的数据</span>OK127.0.0.1:6379<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">></span> get key1<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>127.0.0.1:6379<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">></span> <span class="token keyword">select</span> 2OK127.0.0.1:6379<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token operator">></span> get key2<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>127.0.0.1:6379<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token operator">></span></code></pre><h4 id="SSL-TLS-连接"><a href="#SSL-TLS-连接" class="headerlink" title="SSL/TLS 连接"></a>SSL/TLS 连接</h4></li></ul></li><li><p><a href="https://redis.io/docs/manual/security/encryption/">TLS 官方参考</a></p></li><li><p>默认情况下，redis-cli 使用明文 TCP 连接 redis server，可以通过 –tls 启动安全的 redis server, 通过 –cacert or –cacertdir 配置信任根证书，如果目标 redis server 要求客户端认证，需要在客户端通过参数 –cert 和 –key 配置证书和配对的私钥连接启动 tls 的 redis server </p></li><li><p>生成证书和私钥</p><ul><li><p>官方提供生成证书和私钥的脚本 <code>gen-test-certs.sh</code></p><ul><li>脚本使用 openssl 工具生成私钥和证书的，对于 openssl 的命令参数可以参考 <a href="https://www.openssl.org/">openssl 官网</a>    </li></ul></li></ul><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true"># Generate some test certificates which are used by the regression test suite:</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#   tests/tls/ca.&amp;#123;crt,key&amp;#125;          Self signed CA certificate.</span><span class="token comment" spellcheck="true">#   tests/tls/redis.&amp;#123;crt,key&amp;#125;       A certificate with no key usage/policy restrictions.</span><span class="token comment" spellcheck="true">#   tests/tls/client.&amp;#123;crt,key&amp;#125;      A certificate restricted for SSL client usage.</span><span class="token comment" spellcheck="true">#   tests/tls/server.&amp;#123;crt,key&amp;#125;      A certificate restricted for SSL server usage.</span><span class="token comment" spellcheck="true">#   tests/tls/redis.dh              DH Params file.</span>generate_cert<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>local name<span class="token operator">=</span><span class="token variable">$1</span>local cn<span class="token operator">=</span><span class="token string">"<span class="token variable">$2</span>"</span>local opts<span class="token operator">=</span><span class="token string">"<span class="token variable">$3</span>"</span>local keyfile<span class="token operator">=</span>tests/tls/$<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;name&amp;#125;.key</span>local certfile<span class="token operator">=</span>tests/tls/$<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;name&amp;#125;.crt</span><span class="token punctuation">[</span> -f <span class="token variable">$keyfile</span> <span class="token punctuation">]</span> <span class="token operator">||</span> openssl genrsa -out <span class="token variable">$keyfile</span> 2048openssl req \-new -sha256 \-subj <span class="token string">"/O=Redis Test/CN=<span class="token variable">$cn</span>"</span> \-key <span class="token variable">$keyfile</span> <span class="token operator">|</span> \openssl x509 \-req -sha256 \-CA tests/tls/ca.crt \-CAkey tests/tls/ca.key \-CAserial tests/tls/ca.txt \-CAcreateserial \-days 365 \<span class="token variable">$opts</span> \-out <span class="token variable">$certfile</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span class="token function">mkdir</span> -p tests/tls<span class="token punctuation">[</span> -f tests/tls/ca.key <span class="token punctuation">]</span> <span class="token operator">||</span> openssl genrsa -out tests/tls/ca.key 4096openssl req \-x509 -new -nodes -sha256 \-key tests/tls/ca.key \-days 3650 \-subj <span class="token string">'/O=Redis Test/CN=Certificate Authority'</span> \-out tests/tls/ca.crt<span class="token function">cat</span> <span class="token operator">></span> tests/tls/openssl.cnf <span class="token operator">&lt;&lt;</span><span class="token string">_END_[ server_cert ]keyUsage = digitalSignature, keyEnciphermentnsCertType = server[ client_cert ]keyUsage = digitalSignature, keyEnciphermentnsCertType = client_END_</span>generate_cert server <span class="token string">"Server-only"</span> <span class="token string">"-extfile tests/tls/openssl.cnf -extensions server_cert"</span>generate_cert client <span class="token string">"Client-only"</span> <span class="token string">"-extfile tests/tls/openssl.cnf -extensions client_cert"</span>generate_cert redis <span class="token string">"Generic-cert"</span><span class="token punctuation">[</span> -f tests/tls/redis.dh <span class="token punctuation">]</span> <span class="token operator">||</span> openssl dhparam -out tests/tls/redis.dh 2048</code></pre><p>会在当前目录下创建 tests/tls/ 目录，包含以下文件</p><pre class=" language-bash"><code class="language-bash">ca.crtca.keyca.txtclient.crtclient.keyopenssl.cnfredis.crtredis.dhredis.keyserver.crtserver.key</code></pre><ul><li><p>启动 TLS redis server</p></li><li><p>当前所在的目录 redis/  redis 有一个子目录为 tests    </p></li></ul><pre class=" language-bash"><code class="language-bash">$ redis-server --tls-port 6379 --port 0 \                              --tls-cert-file ./tests/tls/redis.crt \--tls-key-file ./tests/tls/redis.key \--tls-ca-cert-file ./tests/tls/ca.crt</code></pre><p>参数解析</p><pre class=" language-bash"><code class="language-bash">--tls-port 6379 <span class="token comment" spellcheck="true"># 表示在指定的端口如 6379 上允许接受 SSL/TLS 连接</span>--port 0 <span class="token comment" spellcheck="true"># 允许同时接受非 SSL 和 SSL 端口，当 port 参数值为 0 时禁止非 SSL 端口连接</span>--tls-cert-file ./tests/tls/redis.crt <span class="token comment" spellcheck="true"># redis server 启动 TLS 的 x.509 格式证书</span>--tls-key-file ./tests/tls/redis.key <span class="token comment" spellcheck="true"># redis server 启动 TLS 的私钥</span>--tls-ca-cert-file ./tests/tls/ca.crt <span class="token comment" spellcheck="true"># redis server 启动 TLS 的根证书 ca</span><span class="token comment" spellcheck="true"># 要支持基于 DH 的密码，还可以配置 DH 参数文件。</span>--tls-dh-params-file ./tests/tls/redis.dh</code></pre><ul><li><p>客户端验证连接</p><p>默认是双向验证连接的，即客户端连接时也需要配置证书</p></li></ul><pre class=" language-bash"><code class="language-bash">$ redis-cli --tls \--cert ./tests/tls/redis.crt \ --key ./tests/tls/redis.key \ --cacert ./tests/tls/ca.crt</code></pre><pre class=" language-bash"><code class="language-bash">--tls <span class="token comment" spellcheck="true"># 表示在使用 SSL/TLS 连接</span>--cert ./tests/tls/redis.crt <span class="token comment" spellcheck="true"># redis client 连接 redis tls server 的 x.509 格式证书</span>--key ./tests/tls/redis.key <span class="token comment" spellcheck="true"># redis 连接 redis tls server 的私钥</span>--cacert ./tests/tls/ca.crt <span class="token comment" spellcheck="true"># redis 连接 redis tls server 的根证书 ca</span></code></pre><ul><li>如果不使用证书时，会提示 <code>Error: Connection reset by peer</code></li></ul><pre class=" language-bash"><code class="language-bash">$ redis-cli        127.0.0.1:6379<span class="token operator">></span> get key1Error: Connection reset by peer</code></pre><ul><li><p>配置禁用客户端身份验证连接 redis 服务(ca 证书必须配置)</p></li><li><p>首先需要在 redis 服务启动时使用配置参数 <code>--tls-auth-clients no</code> 禁用认证客户端</p></li></ul><pre class=" language-bash"><code class="language-bash">$ redis-server --tls-port 6379 --port 0 \--tls-cert-file ./tests/tls/redis.crt \--tls-key-file ./tests/tls/redis.key \--tls-ca-cert-file ./tests/tls/ca.crt \--tls-auth-clients no</code></pre><ul><li>可证书连接</li></ul><pre class=" language-bash"><code class="language-bash">$ redis-cli --tls \--cert ./tests/tls/client.crt \--key ./tests/tls/client.key \--cacert ./tests/tls/ca.crt</code></pre><ul><li>可不使用证书连接</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 可证书连接</span>$ redis-cli --tls \--cacert ./tests/tls/ca.crt</code></pre><h4 id="从其他程序输入"><a href="#从其他程序输入" class="headerlink" title="从其他程序输入"></a>从其他程序输入</h4></li><li><p>使用 -x 选项接受有效负载的最后一个参数值</p></li></ul><pre class=" language-bash"><code class="language-bash">  <span class="token comment" spellcheck="true"># 给 `net_services` key 设置来自本地文件系统 `/etc/services` 的值,</span>  <span class="token comment" spellcheck="true"># -x 将文件重定向到 CLI 的标准输入作为满足 `SET net_services` 命令的值</span>  $ redis-cli -x SET net_services <span class="token operator">&lt;</span> /etc/services  OK  $ redis-cli GETRANGE net_services 0 50  <span class="token string">"#\n# Network services, Internet style\n#\n# Note that "</span></code></pre><ul><li>给 redis-cli 喂养一系列写在文本文件中的命令脚本</li></ul><pre class=" language-bash"><code class="language-bash">  $ <span class="token function">cat</span> /tmp/commands.txt  SET item:3374 100  INCR item:3374  APPEND item:3374 xxx  GET item:3374  $ <span class="token function">cat</span> /tmp/commands.txt <span class="token operator">|</span> redis-cli  OK  <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 101  <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6  <span class="token string">"101xxx"</span>  <span class="token comment" spellcheck="true"># commands.txt 中的所有命令都会被连续执行</span></code></pre><h4 id="连续运行相同的命令"><a href="#连续运行相同的命令" class="headerlink" title="连续运行相同的命令"></a>连续运行相同的命令</h4><ul><li>选项 -r : -r &lt;count&gt; ,设置命令的运行次数</li></ul><pre class=" language-bash"><code class="language-bash">$ redis-cli -r 5 INCR counter_value<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5$ redis-cli -r 8 INCR counter_value <span class="token comment" spellcheck="true"># 连续执行 5 次后，修改为连续执行 8 次</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 7<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 8<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 9<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 10<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 11<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 12<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 13overdose@OverdosedeMacBook-Air redis %<span class="token comment" spellcheck="true"># 在交互模式下，在命令名称前加上一个数字，可以多次运行相同的命令</span>127.0.0.1:6379<span class="token operator">></span> 5 INCR mycounter<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5</code></pre><ul><li>选项 -i : -i &lt;delay&gt; ,设置不同命令调用之间的延迟（以秒为单位）（能够指定诸如 0.1 之类的值来表示 100 毫秒）,表示命令之间的执行需要延迟多少时间<ul><li>当 -r 的参数值为 -1 时，表示无限次执行</li></ul></li></ul><pre class=" language-bash"><code class="language-bash">$ redis-cli -r -1 -i 1 INFO <span class="token operator">|</span> <span class="token function">grep</span> rss_humanused_memory_rss_human:2.71Mused_memory_rss_human:2.73Mused_memory_rss_human:2.73Mused_memory_rss_human:2.73M</code></pre><h4 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h4><ul><li><p>官方表示这部分内容很重要，单独一页面介绍：<a href="https://redis.io/docs/reference/patterns/bulk-loading/">https://redis.io/docs/reference/patterns/bulk-loading/</a></p></li><li><p>批量加载：批量加载是使用大量预先存在的数据加载到 Redis 的过程。</p></li><li><p>首先方法：创建一个包含 Redis 协议的原始格式的 text 文本文件，以便调用插入所需数据所需的命令</p><ul><li>例如，如果我需要生成一个大型数据集，其中有数十亿个键，格式为：`keyN -&gt; ValueN’，我将创建一个包含以下 Redis 协议格式的命令的文件：</li></ul><pre class=" language-bash"><code class="language-bash">SET Key0 Value0SET Key1 Value1<span class="token punctuation">..</span>.SET KeyN ValueN</code></pre><ul><li>创建此文件后，剩下的操作就是尽快将其提供给 Redis。过去这样做的方法是使用 netcat以下命令：</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">(</span>cat data.txt<span class="token punctuation">;</span> <span class="token function">sleep</span> 10<span class="token punctuation">)</span> <span class="token operator">|</span> nc localhost 6379 <span class="token operator">></span> /dev/null</code></pre><ul><li>但是这不推荐，因为 netcat 并不真正知道所有数据何时传输并且无法检查错误，推荐在 Redis 2.6 或更高的版本使用以下专门设计为批量加载的管道模式</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> data.txt <span class="token operator">|</span> redis-cli --pipe</code></pre><ul><li>执行完成会有如下类似的输出反馈</li></ul><pre class=" language-bash"><code class="language-bash">All data transferred. Waiting <span class="token keyword">for</span> the last reply<span class="token punctuation">..</span>.Last reply received from server.errors: 0, replies: 1000000</code></pre><ul><li>上面提及批量加载需要生成 Redis 协议<ul><li><a href="https://redis.io/docs/reference/protocol-spec/">协议规范 RESP</a></li></ul></li></ul><pre class=" language-bash"><code class="language-bash">*<span class="token operator">&lt;</span>args<span class="token operator">></span><span class="token operator">&lt;</span>cr<span class="token operator">></span><span class="token operator">&lt;</span>lf<span class="token operator">></span>$<span class="token operator">&lt;</span>len<span class="token operator">></span><span class="token operator">&lt;</span>cr<span class="token operator">></span><span class="token operator">&lt;</span>lf<span class="token operator">></span><span class="token operator">&lt;</span>arg0<span class="token operator">></span><span class="token operator">&lt;</span>cr<span class="token operator">></span><span class="token operator">&lt;</span>lf<span class="token operator">></span><span class="token operator">&lt;</span>arg1<span class="token operator">></span><span class="token operator">&lt;</span>cr<span class="token operator">></span><span class="token operator">&lt;</span>lf<span class="token operator">></span><span class="token punctuation">..</span>.<span class="token operator">&lt;</span>argN<span class="token operator">></span><span class="token operator">&lt;</span>cr<span class="token operator">></span><span class="token operator">&lt;</span>lf<span class="token operator">></span></code></pre><p>其中&lt;cr&gt;表示“\r”（或 ASCII 字符 13），&lt;lf&gt;表示“\n”（或 ASCII 字符 10）</p><p>例如 set key value 命令的协议如下</p><pre class=" language-bash"><code class="language-bash">*3<span class="token operator">&lt;</span>cr<span class="token operator">></span><span class="token operator">&lt;</span>lf<span class="token operator">></span><span class="token variable">$3</span><span class="token operator">&lt;</span>cr<span class="token operator">></span><span class="token operator">&lt;</span>lf<span class="token operator">></span>SET<span class="token operator">&lt;</span>cr<span class="token operator">></span><span class="token operator">&lt;</span>lf<span class="token operator">></span><span class="token variable">$3</span><span class="token operator">&lt;</span>cr<span class="token operator">></span><span class="token operator">&lt;</span>lf<span class="token operator">></span>key<span class="token operator">&lt;</span>cr<span class="token operator">></span><span class="token operator">&lt;</span>lf<span class="token operator">></span><span class="token variable">$5</span><span class="token operator">&lt;</span>cr<span class="token operator">></span><span class="token operator">&lt;</span>lf<span class="token operator">></span>value<span class="token operator">&lt;</span>cr<span class="token operator">></span><span class="token operator">&lt;</span>lf<span class="token operator">></span></code></pre><p>带引号字符串表示</p><pre class=" language-bash"><code class="language-bash"><span class="token string">"*3\r\n<span class="token variable">$3</span>\r\nSET\r\n<span class="token variable">$3</span>\r\nkey\r\n<span class="token variable">$5</span>\r\nvalue\r\n"</span></code></pre><p>如果需要批量生成，则需要按照格式组装命令即可</p><ul><li><p>管道模式如何在幕后工作</p><ul><li>redis-cli –pipe 尝试尽可能快地向服务器发送数据。</li><li>同时它会在可用时读取数据，并尝试对其进行解析。</li><li>一旦没有更多数据要从标准输入读取，它会发送一个特殊的ECHO 命令，其中包含一个随机的 20 字节字符串：我们确定这是最新发送的命令，并且我们确信如果我们收到相同的 20，我们可以匹配回复检查字节作为批量回复。</li><li>一旦发送了这个特殊的最终命令，接收回复的代码就会开始匹配这 20 个字节的回复。当达到匹配的回复时，它可以成功退出。</li></ul><p>使用这个技巧，我们不需要解析我们发送到服务器的协议来了解我们发送了多少命令，而只需解析回复。</p><p>然而，在解析回复时，我们对所有解析的回复进行计数，以便最后我们能够告诉用户通过批量插入会话传输到服务器的命令数量。</p></li></ul></li></ul><h4 id="CSV-格式输出"><a href="#CSV-格式输出" class="headerlink" title="CSV 格式输出"></a>CSV 格式输出</h4><ul><li><p>CSV ： Comma Separated Values ，逗号分隔值</p><pre class=" language-bash"><code class="language-bash">$ redis-cli LPUSH mylist a b c d<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4$ redis-cli --csv LRANGE mylist 0 -1<span class="token string">"d"</span>,<span class="token string">"c"</span>,<span class="token string">"b"</span>,<span class="token string">"a"</span></code></pre><h4 id="还可以运行-Lua-脚本"><a href="#还可以运行-Lua-脚本" class="headerlink" title="还可以运行 Lua 脚本"></a>还可以运行 Lua 脚本</h4></li></ul><h4 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h4><ul><li>在交互模式下，用户在提示符下键入 Redis 命令。该命令被发送到服务器，进行处理，然后将回复解析并呈现为更简单的形式以供阅读。</li><li>在交互模式下运行不需要什么特别的redis-cli- 只需在没有任何参数的情况下执行它</li></ul><pre class=" language-bash"><code class="language-bash">$ redis-cli127.0.0.1:6379<span class="token operator">></span> PINGPONG</code></pre><p>  字符串127.0.0.1:6379&gt;是提示符。它显示连接的 Redis 服务器实例的主机名和端口。</p><p>  当连接的服务器更改或在与数据库编号为零的数据库不同的数据库上操作时，提示会更新：</p><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> SELECT 2OK127.0.0.1:6379<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token operator">></span> DBSIZE<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1127.0.0.1:6379<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token operator">></span> SELECT 0OK127.0.0.1:6379<span class="token operator">></span> DBSIZE<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 503</code></pre><h4 id="处理连接和重连"><a href="#处理连接和重连" class="headerlink" title="处理连接和重连"></a>处理连接和重连</h4><ul><li>使用 CONNECT 命令在交互模式下连接不同的实例</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 启动另外一个实例，端口为 6380，在 6379 端口的实例交互模式下连接 6380</span>overdose@OverdosedeMacBook-Air redis % redis-cli 127.0.0.1:6379<span class="token operator">></span> get key1<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>127.0.0.1:6379<span class="token operator">></span> connect localhost 6380localhost:6380<span class="token operator">></span></code></pre><ul><li>断开重连</li></ul><p>  一般检测到断线后，redis-cli总是尝试透明重连；如果尝试失败，则显示错误并进入断开连接状态。以下是断开和重新连接的示例：</p><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> INFO SERVERCould not connect to Redis at 127.0.0.1:6379: Connection refusednot connected<span class="token operator">></span> PINGPONG127.0.0.1:6379<span class="token operator">></span><span class="token punctuation">(</span>now we are connected again<span class="token punctuation">)</span></code></pre><h4 id="redis-cli-命令提示"><a href="#redis-cli-命令提示" class="headerlink" title="redis-cli 命令提示"></a>redis-cli 命令提示</h4><ul><li>历史记录都存在一个 <code>.rediscli_history</code> 文件</li><li>输入命令后按 TAB 键，可以看到命令的使用提示</li></ul><pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> Z<span class="token operator">&lt;</span>TAB<span class="token operator">></span>127.0.0.1:6379<span class="token operator">></span> ZADD<span class="token operator">&lt;</span>TAB<span class="token operator">></span>127.0.0.1:6379<span class="token operator">></span> ZCARD<span class="token operator">&lt;</span>TAB<span class="token operator">></span></code></pre><h4 id="命令帮助"><a href="#命令帮助" class="headerlink" title="命令帮助"></a>命令帮助</h4><ul><li>场景：对于某个命令的使用不清楚可以参考查看</li><li><a href="https://redis.io/commands/">在线命令帮助</a></li><li>help 帮助命令</li><li>首先，通过对类别查看，可以获取该类别下的所有命令及大致用法</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">help</span> @<span class="token operator">&lt;</span>category<span class="token operator">></span> <span class="token comment" spellcheck="true"># @&lt;category> 包含以下的类别</span>@generic@string@list@set@sorted_set@hash@pubsub@transactions@connection@server@scripting@hyperloglog@cluster@geo@stream<span class="token comment" spellcheck="true"># 以 string 类别为例</span>127.0.0.1:6380<span class="token operator">></span> <span class="token function">help</span> @string<span class="token punctuation">..</span>.GET key <span class="token comment" spellcheck="true"># 命令的执行格式</span>summary: Get the value of a key <span class="token comment" spellcheck="true"># 命令的作用描述，获取一个 key 对应的值</span>since: 1.0.0 <span class="token comment" spellcheck="true"># 命令出现的版本</span>SET key value <span class="token punctuation">[</span>NX<span class="token operator">|</span>XX<span class="token punctuation">]</span> <span class="token punctuation">[</span>GET<span class="token punctuation">]</span> <span class="token punctuation">[</span>EX seconds<span class="token operator">|</span>PX milliseconds<span class="token operator">|</span>EXAT unix-time-seconds<span class="token operator">|</span>PXAT unix-time-milliseconds<span class="token operator">|</span>KEEPTTL<span class="token punctuation">]</span>summary: Set the string value of a keysince: 1.0.0<span class="token punctuation">..</span>.</code></pre><ul><li>其次，查看具体某个命令的用法</li></ul><pre class=" language-bash"><code class="language-bash">127.0.0.1:6380<span class="token operator">></span> <span class="token function">help</span> GETGET keysummary: Get the value of a keysince: 1.0.0group: string</code></pre><h4 id="清理屏幕"><a href="#清理屏幕" class="headerlink" title="清理屏幕"></a>清理屏幕</h4><ul><li>跟 shell 终端使用 <code>clear</code> 命令清除屏幕一样的效果,即隐藏之前记录，变为首行的效果</li></ul><pre class=" language-bash"><code class="language-bash">127.0.0.1:6380<span class="token operator">></span> <span class="token function">clear</span>127.0.0.1:6380<span class="token operator">></span></code></pre><h4 id="特殊的操作模式"><a href="#特殊的操作模式" class="headerlink" title="特殊的操作模式"></a>特殊的操作模式</h4><ul><li>用于显示有关 Redis 服务器的连续统计信息的监控工具,使用命令参数 <code>--stat</code></li></ul><pre class=" language-bash"><code class="language-bash">$ redis-cli --stat------- data ------ --------------------- load -------------------- - child -keys       mem      clients blocked requests            connections          2          1.88M    1       0       33 <span class="token punctuation">(</span>+0<span class="token punctuation">)</span>             8           2          1.86M    1       0       34 <span class="token punctuation">(</span>+1<span class="token punctuation">)</span>             8           2          1.86M    1       0       35 <span class="token punctuation">(</span>+1<span class="token punctuation">)</span>             8           2          1.87M    1       0       36 <span class="token punctuation">(</span>+1<span class="token punctuation">)</span>             8           2          1.87M    1       0       37 <span class="token punctuation">(</span>+1<span class="token punctuation">)</span>             8           2          1.87M    1       0       38 <span class="token punctuation">(</span>+1<span class="token punctuation">)</span>             8           2          1.86M    1       0       39 <span class="token punctuation">(</span>+1<span class="token punctuation">)</span>             8           2          1.86M    1       0       40 <span class="token punctuation">(</span>+1<span class="token punctuation">)</span>             8           ^C$</code></pre><ul><li>扫描最大的 key<ul><li>根据响应可以找到各种类型的 key ,数据占了多少字节</li></ul></li></ul><pre class=" language-bash"><code class="language-bash">$ redis-cli --bigkeys<span class="token comment" spellcheck="true"># Scanning the entire keyspace to find biggest keys as well as</span><span class="token comment" spellcheck="true"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span><span class="token comment" spellcheck="true"># per 100 SCAN commands (not usually needed).</span><span class="token punctuation">[</span>00.00%<span class="token punctuation">]</span> Biggest string found so far <span class="token string">'"counter_value"'</span> with 2 bytes<span class="token punctuation">[</span>00.00%<span class="token punctuation">]</span> Biggest string found so far <span class="token string">'"net_services"'</span> with 677972 bytes-------- summary -------Sampled 2 keys <span class="token keyword">in</span> the keyspace<span class="token operator">!</span>Total key length <span class="token keyword">in</span> bytes is 25 <span class="token punctuation">(</span>avg len 12.50<span class="token punctuation">)</span>Biggest string found <span class="token string">'"net_services"'</span> has 677972 bytes0 lists with 0 items <span class="token punctuation">(</span>00.00% of keys, avg size 0.00<span class="token punctuation">)</span>0 hashs with 0 fields <span class="token punctuation">(</span>00.00% of keys, avg size 0.00<span class="token punctuation">)</span>2 strings with 677974 bytes <span class="token punctuation">(</span>100.00% of keys, avg size 338987.00<span class="token punctuation">)</span>0 streams with 0 entries <span class="token punctuation">(</span>00.00% of keys, avg size 0.00<span class="token punctuation">)</span>0 sets with 0 members <span class="token punctuation">(</span>00.00% of keys, avg size 0.00<span class="token punctuation">)</span>0 zsets with 0 members <span class="token punctuation">(</span>00.00% of keys, avg size 0.00<span class="token punctuation">)</span></code></pre><ul><li>获取密钥列表<ul><li>使用 –scan 命令，不阻塞 redis 服务，还可以过滤</li></ul></li></ul><pre class=" language-bash"><code class="language-bash">$ redis-cli --scan <span class="token operator">|</span> <span class="token function">head</span> -10counter_valuenet_services<span class="token comment" spellcheck="true"># 还可以通过 --pattern 匹配</span>$ redis-cli --scan --pattern <span class="token string">'*-11*'</span>key-114key-117key-118key-113key-115key-112key-119key-11key-111key-110key-116</code></pre><ul><li>发布/订阅模式</li><li>CLI 可以在 Redis 发布/订阅 channel 通道使用 <code>PUBLISH</code> 命令发布消息。订阅 channel 通道是为了接收消息，因此在终端会被阻塞等待。</li><li>不像其他特殊模式有其他命令参数，发布/订阅只有命令 <code>PSUBSCRIBE</code>(发布) 和 <code>SUBSCRIBE</code>(订阅)</li><li>查看<code>PSUBSCRIBE</code> 和 <code>SUBSCRIBE</code> 命令使用</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># PSUBSCRIBE</span>127.0.0.1:6379<span class="token operator">></span> <span class="token function">help</span> PSUBSCRIBEPSUBSCRIBE pattern <span class="token punctuation">[</span>pattern <span class="token punctuation">..</span>.<span class="token punctuation">]</span>summary: Listen <span class="token keyword">for</span> messages published to channels matching the given patternssince: 2.0.0group: pubsub<span class="token comment" spellcheck="true"># SUBSCRIBE</span>127.0.0.1:6379<span class="token operator">></span> <span class="token function">help</span> SUBSCRIBESUBSCRIBE channel <span class="token punctuation">[</span>channel <span class="token punctuation">..</span>.<span class="token punctuation">]</span>summary: Listen <span class="token keyword">for</span> messages published to the given channelssince: 2.0.0group: pubsub</code></pre><ul><li>在一个客户端 A 启动发布/订阅模式</li></ul><pre class=" language-bash"><code class="language-bash">$ redis-cli PSUBSCRIBE <span class="token string">'*'</span>Reading messages<span class="token punctuation">..</span>. <span class="token punctuation">(</span>press Ctrl-C to quit<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 表示当前客户端进入发布/订阅模式</span>1<span class="token punctuation">)</span> <span class="token string">"psubscribe"</span>2<span class="token punctuation">)</span> <span class="token string">"*"</span>3<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre><ul><li>启动另一个客户端 B，发布消息</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看 PUBLISH 命令使用</span>127.0.0.1:6379<span class="token operator">></span> <span class="token function">help</span> publishPUBLISH channel messagesummary: Post a message to a channelsince: 2.0.0group: pubsub<span class="token comment" spellcheck="true"># 参照 `PUBLISH channel message` 用法发布消息</span>$ redis-cli PUBLISH mychannel mymessage<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1$ redis-cli PUBLISH mychannel mymessage2<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1<span class="token comment" spellcheck="true"># 此时，在客户端 A 收到消息以及格式如下</span>$ redis-cli PSUBSCRIBE <span class="token string">'*'</span>Reading messages<span class="token punctuation">..</span>. <span class="token punctuation">(</span>press Ctrl-C to quit<span class="token punctuation">)</span>1<span class="token punctuation">)</span> <span class="token string">"psubscribe"</span>2<span class="token punctuation">)</span> <span class="token string">"*"</span>3<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 11<span class="token punctuation">)</span> <span class="token string">"pmessage"</span> <span class="token comment" spellcheck="true"># 第一次接收数据</span>2<span class="token punctuation">)</span> <span class="token string">"*"</span>3<span class="token punctuation">)</span> <span class="token string">"mychannel"</span>4<span class="token punctuation">)</span> <span class="token string">"mymessage"</span>1<span class="token punctuation">)</span> <span class="token string">"pmessage"</span> <span class="token comment" spellcheck="true"># 第二次接收数据</span>2<span class="token punctuation">)</span> <span class="token string">"*"</span>3<span class="token punctuation">)</span> <span class="token string">"mychannel"</span> <span class="token comment" spellcheck="true"># channel 名字</span>4<span class="token punctuation">)</span> <span class="token string">"mymessage2"</span> <span class="token comment" spellcheck="true"># message 消息</span><span class="token comment" spellcheck="true"># CTRL-C 退出 发布/订阅模式</span></code></pre><ul><li>监控 Redis 中执行的命令<ul><li>跟上面的发布/订阅模式有点像，一旦使用 <code>MONITOR</code> 命令，就会自动进入监控模式。活动 Redis 实例接收到的所有命令都将打印到标准输出：</li><li>客户端 A 进入监控模式</li></ul><pre class=" language-bash"><code class="language-bash">$ redis-cli monitorOK<span class="token comment" spellcheck="true"># 客户端 B 执行完命令操作后，客户端 A 出现以下内容</span>$ redis-cli monitorOK1663038437.104451 <span class="token punctuation">[</span>0 127.0.0.1:58590<span class="token punctuation">]</span> <span class="token string">"COMMAND"</span> <span class="token string">"DOCS"</span>1663038456.134602 <span class="token punctuation">[</span>0 127.0.0.1:58590<span class="token punctuation">]</span> <span class="token string">"set"</span> <span class="token string">"key1"</span> <span class="token string">"hello"</span>1663038460.157135 <span class="token punctuation">[</span>0 127.0.0.1:58590<span class="token punctuation">]</span> <span class="token string">"get"</span> <span class="token string">"key1"</span></code></pre><ul><li>客户端 B 执行命令操作</li></ul><pre class=" language-bash"><code class="language-bash">$ redis-cli127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">set</span> key1 helloOK127.0.0.1:6379<span class="token operator">></span> get key1<span class="token string">"hello"</span>127.0.0.1:6379<span class="token operator">></span></code></pre><ul><li>RDB 文件的远程备份<ul><li>确保 Redis 实例的灾难恢复,允许将 RDB 文件从任何 Redis 实例传输到正在运行的本地计算机,通过 redis-cli <code>--rdb &lt;dest-filename&gt;</code>完成</li></ul></li></ul><pre class=" language-bash"><code class="language-bash">$ redis-cli --rdb /tmp/dump.rdbSYNC sent to master, writing 13256 bytes to <span class="token string">'/tmp/dump.rdb'</span>Transfer finished with success.</code></pre><ul><li>副本模式<ul><li>CLI 的副本模式是对 Redis 开发人员和调试操作有用的高级功能。它允许检查主节点在复制流中发送到其副本的内容，以便将写入传播到其副本。选项名称很简单–replica。以下是一个工作示例：</li></ul></li></ul><pre class=" language-bash"><code class="language-bash">$ redis-cli --replicasending REPLCONF rdb-filter-only SYNC with master, discarding bytes of bulk transfer <span class="token keyword">until</span> EOF marker<span class="token punctuation">..</span>.SYNC <span class="token keyword">done</span> after 211 bytes. Logging commands from master.sending REPLCONF ACK 0<span class="token string">"ping"</span><span class="token string">"ping"</span><span class="token string">"ping"</span><span class="token string">"ping"</span><span class="token punctuation">..</span>.</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2022/02/28/design-pattern/"/>
      <url>/2022/02/28/design-pattern/</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解。</p></blockquote><h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gztkl0sjsnj22360u0do4.jpg" alt="面向对象设计原则" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> DesignPattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell</title>
      <link href="/2022/02/24/shell/"/>
      <url>/2022/02/24/shell/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录 shell 学习小知识</p><p>Shell 是一个程序，一般都是放在<code>/bin</code>或者<code>/usr/bin</code>目录下</p></blockquote><h3 id="查看内置的-shell-解释器种类"><a href="#查看内置的-shell-解释器种类" class="headerlink" title="查看内置的 shell 解释器种类"></a>查看内置的 shell 解释器种类</h3><p>当前 Linux 系统可用的 Shell 都记录在<code>/etc/shells</code>文件中,执行 cat /etc/shells 可查看</p><pre class=" language-shell"><code class="language-shell">overdose@OverdosedeMacBook-Air shell_test % cat /etc/shells# List of acceptable shells for chpass(1).# Ftpd will not allow users to connect who are not using# one of these shells./bin/bash #/bin/csh/bin/dash/bin/ksh/bin/sh/bin/tcsh/bin/zsh</code></pre><ul><li><p>sh</p><ul><li>sh 的全称是 Bourne shell，由 AT&amp;T 公司的 Steve Bourne开发，为了纪念他，就用他的名字命名了。</li><li>sh 是 UNIX 上的标准 shell，很多 UNIX 版本都配有 sh。sh 是第一个流行的 Shell。</li></ul></li><li><p>bash</p><ul><li><p>bash shell 是 Linux 的默认 shell，本教程也基于 bash 编写。</p><p>bash 由 GNU 组织开发，保持了对 sh shell 的兼容性，是各种 Linux 发行版默认配置的 shell。</p><blockquote><p>bash 兼容 sh 意味着，针对 sh 编写的 Shell 代码可以不加修改地在 bash 中运行。</p></blockquote></li></ul></li><li><p>csh</p><ul><li>sh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。</li></ul></li><li><p>tcsh</p><ul><li>tcsh 是 csh 的增强版，加入了命令补全功能，提供了更加强大的语法支持。</li></ul></li><li><p>zsh</p><ul><li>Zsh 是一种为交互式使用而设计的 shell</li></ul></li><li><p>ksh</p><ul><li><strong>KornShell</strong> ( <strong>ksh</strong>) 是一个<a href="https://en.wikipedia.org/wiki/Unix_shell">Unix shell</a>，由<a href="https://en.wikipedia.org/wiki/David_Korn_(computer_scientist)">David Korn</a>在1980 年代初期在贝尔实验室开发</li></ul></li></ul><h3 id="查看当前默认的-Shell-解释器"><a href="#查看当前默认的-Shell-解释器" class="headerlink" title="查看当前默认的 Shell 解释器"></a>查看当前默认的 Shell 解释器</h3><p>SHELL 为内置变量，在 shell 中表示默认解释器, macbook 中默认是 zsh , linux 默认是 /bin/bash</p><pre class=" language-shell"><code class="language-shell">overdose@OverdosedeMacBook-Air shell_test % echo $SHELL/bin/zsh</code></pre><h3 id="Linux-Shell命令的基本格式"><a href="#Linux-Shell命令的基本格式" class="headerlink" title="Linux Shell命令的基本格式"></a>Linux Shell命令的基本格式</h3><p>overdose@OverdosedeMacBook-Air shell_test %</p><p>overdose : 表示当前登录的用户</p><p>@ ：分隔符作用</p><p>OverdosedeMacBook-Air ： 主机名</p><p>shell_test ：用户所在的当前目录</p><h3 id="第一个-Shell-程序"><a href="#第一个-Shell-程序" class="headerlink" title="第一个 Shell 程序"></a>第一个 Shell 程序</h3><pre class=" language-shell"><code class="language-shell">#! /bin/bashvariable="HelloWorld"echo $variable</code></pre><p>保存为 <code>test.sh</code> 脚本程序</p><p>#! : 规约标记，表示指定使用哪个解释器，/bin/bash 解释器的位置（这个值的填写参考 cat /etc/shells 结果）</p><h3 id="Shell-程序的执行方式"><a href="#Shell-程序的执行方式" class="headerlink" title="Shell 程序的执行方式"></a>Shell 程序的执行方式</h3><ul><li>开启新进程运行<ul><li>给 test.sh 设置执行权限 ，chmod +x test.sh，执行 ：./test.sh</li><li>直接指定解释器，这时 #! /bin/bash 指定的解释器无效 ，执行 ：/bin/bash test.sh</li></ul></li><li>当前进程运行(./ 在 linux 中可有可无，在 macbook 得需要)<ul><li>source ./test.sh : source 命令强制读取 test.sh 中的命令一行一行执行</li><li>. ./test.sh ：点 . 跟 test.sh 之间有个空格</li></ul></li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>定义变量</p><ul><li><p>不需要指定类型，只需要一个变量名，= 等号两边不能有空格</p><pre class=" language-shell"><code class="language-shell">variable=value #     无引号（当值中含有空格，tab缩进时，必须使用引号定义变量）variable='value' # 单引号variable="value" # 双引号</code></pre><p>在 /bin/bash 中默认是字符串，不管是 数字，或浮点数</p></li><li><p>命名规则</p><ul><li>变量名由数字、字母、下划线组成；</li><li>必须以字母或者下划线开头；</li><li>不能使用 Shell 里的关键字（通过 help 命令可以查看保留关键字）。</li></ul><pre class=" language-shell"><code class="language-shell">url=https://yuan-hy.github.io/echo $urlname='yuan'echo $nameauthor="yuan-hy"echo $author</code></pre></li></ul></li><li><p>使用变量</p><ul><li><p>使用一个定义过的变量，只要在变量名前面加美元符号<code>$</code>即可</p><pre class=" language-shell"><code class="language-shell">author="yuan-hy"echo $authorecho $&#123;author&#125;</code></pre><p>变量名外面的花括号{} 是可选的，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p><pre><code>skill=&quot;Java&quot;echo &quot;I am good at $&#123;skill&#125;Script&quot;</code></pre><p>如果不给 skill 变量加花括号，写成<code>echo &quot;I am good at $skillScript&quot;</code>，解释器就会把 $skillScript 当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p><p><strong>推荐给所有变量加上花括号<code>&#123; &#125;</code>，这是个良好的编程习惯。</strong></p></li></ul></li><li><p>修改变量的值</p><ul><li><p>已定义的变量，可以被重新赋值，如：</p><pre class=" language-shell"><code class="language-shell">url="https://yuan-hy.github.io/"echo $&#123;url&#125;url="https://yuan-hy.github.io"echo $&#123;url&#125;</code></pre></li></ul><p>第二次对变量赋值时不能在变量名前加<code>$</code>，只有在使用变量时才能加<code>$</code>。</p></li><li><p>单引号和双引号的区别</p><pre class=" language-shell"><code class="language-shell">#!/bin/bashurl="https://yuan-hy.github.io/"website1='个人网站：$&#123;url&#125;'website2="个人网站：$&#123;url&#125;"echo $website1echo $website2</code></pre><p>运行结果：<br>C语言中文网：${url}<br>C语言中文网：<a href="https://yuan-hy.github.io/">https://yuan-hy.github.io/</a></p><p>以单引号<code>&#39; &#39;</code>包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。</p><p>以双引号<code>&quot; &quot;</code>包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。</p><p><strong>建议：如果变量的内容是数字，那么可以不加引号；如果真的需要原样输出就加单引号；其他没有特别要求的字符串等最好都加上双引号，定义变量时加双引号是最常见的使用场景。</strong></p></li><li><p>将命令的结果赋值给变量</p></li></ul><p>​            Shell 也支持将命令的执行结果赋值给变量，常见的有以下两种方式：</p><p>​            variable=<code>command</code><br>​            variable=$(command)</p><p>​            第一种方式把命令用反引号（位于 Esc 键的下方）包围起来，反引号和单引号非常相似，容易产生混淆，所以不推荐使用这种方            式；</p><p>​            第二种方式把命令用<code>$()</code>包围起来，区分更加明显，所以推荐使用这种方式。</p><p>​            例如，我在 demo 目录中创建了一个名为 log.txt 的文本文件，用来记录我的日常工作。下面的代码中，使用 cat 命令将 log.txt             的内容读取出来，并赋值给一个变量，然后使用 echo 命令输出。</p><pre class=" language-shell"><code class="language-shell">    [overdose@OverdosedeMacBook-Air ~]$ cd demo    [overdose@OverdosedeMacBook-Air demo]$ log=$(cat log.txt)    [overdose@OverdosedeMacBook-Air demo]$ echo $log    yuan-hy 个人网站地址：https://yuan-hy.github.io/    [overdose@OverdosedeMacBook-Air demo]$ log=`cat log.txt`    [overdose@OverdosedeMacBook-Air demo]$ echo $log    yuan-hy 个人网站地址：https://yuan-hy.github.io/</code></pre><ul><li>只读变量</li></ul><p>使用 <strong>readonly</strong> 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><p>下面的例子尝试更改只读变量，结果报错：</p><pre class=" language-shell"><code class="language-shell">#!/bin/bashmyUrl="https://yuan-hy.github.io/"readonly myUrlmyUrl="https://yuan-hy.github.io/"</code></pre><p>运行脚本，结果如下：</p><pre><code>bash: myUrl: This variable is read only.</code></pre><ul><li>删除变量</li></ul><p>使用 <strong>unset</strong> 命令可以删除变量。语法：</p><pre class=" language-shell"><code class="language-shell">unset variable_name</code></pre><p>变量被删除后不能再次使用；unset 命令不能删除只读变量。</p><p>举个例子：</p><pre class=" language-shell"><code class="language-shell">#!/bin/bashmyUrl="https://yuan-hy.github.io/"unset myUrlecho $myUrl</code></pre><p>上面的脚本没有任何输出。</p><ul><li><p>变量的作用域</p><p><a href="http://c.biancheng.net/view/773.html">参考链接</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 命令积累</title>
      <link href="/2022/01/30/linuxcommand/"/>
      <url>/2022/01/30/linuxcommand/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录 linux 命令小知识</p></blockquote><h3 id="alias-与-unalias"><a href="#alias-与-unalias" class="headerlink" title="alias 与 unalias"></a>alias 与 unalias</h3><p>背景 ：当命令很长的时候，可以通过自定义别名来减少输入，节省时间，也可以通过定制命令防止出现操作不当</p><ul><li><p>查看当前系统存在的别名</p><pre class=" language-shell"><code class="language-shell">overdose@OverdosedeMacBook-Air ~ % aliasrun-help=manwhich-command=whence</code></pre></li><li><p>为 clear 设置 cl 别名,设置别名后，查看 alias ，可以看到已设置别名成功</p><pre class=" language-shell"><code class="language-shell">overdose@OverdosedeMacBook-Air ~ % alias cl='clear'overdose@OverdosedeMacBook-Air ~ % aliascl=clearrun-help=manwhich-command=whence</code></pre></li><li><p>取消设置别名 cl,执行取消设置别名后，查看 alias ，可以看到已取消设置别名成功</p><pre class=" language-shell"><code class="language-shell">overdose@OverdosedeMacBook-Air ~ % unalias cloverdose@OverdosedeMacBook-Air ~ % aliasrun-help=manwhich-command=whenceoverdose@OverdosedeMacBook-Air ~ % </code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 虚拟机小知识</title>
      <link href="/2022/01/23/jvm/"/>
      <url>/2022/01/23/jvm/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于阅读 Oracle 官方文档对 JVM 规范的知识积累</p></blockquote><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ul><li><p>Java 虚拟机(简称 <strong>JVM</strong>)是 Java 平台的基石。它是该技术的组成部分，独立于硬件和操作系统、具有轻量编译代码以及保护用户免受恶意程序侵害的能力。</p></li><li><p>Java 虚拟机对 Java 编程语言一无所知，只知道一种特定的二进制格式，即<code>class</code>文件格式。<code>class</code>文件包含 Java 虚拟机指令（或<em>字节码</em>）和符号表，以及其他辅助信息。</p></li><li><p>为了安全起见，Java 虚拟机在 <code>class</code> 文件上的代码强加强大的句法和结构约束。但是，任何具有可以用有效<code>class</code>文件表示的功能的语言都可以由 Java 虚拟机托管(通俗来讲就是一门语言，如果编译后为有效的 <code>class</code> 文件,都可以被 JVM 识别，在 JVM 上运行，例如 groovy 语言)</p></li></ul><h2 id="Java-虚拟机架构"><a href="#Java-虚拟机架构" class="headerlink" title="Java 虚拟机架构"></a>Java 虚拟机架构</h2><p>要正确实现 Java 虚拟机，您只需要能够读取<code>class</code>文件格式并正确执行其中指定的操作即可。不属于 Java 虚拟机规范的实现细节会不必要地限制实现者的创造力。例如，运行时数据区域(<code>run-time data areas</code>)的内存布局、使用的垃圾收集算法(<code>garbage-collection algorithm</code>)以及 Java 虚拟机指令的任何内部优化（例如，将它们转换为机器代码）都由实现者自行决定。</p><h3 id="class-文件格式"><a href="#class-文件格式" class="headerlink" title="class 文件格式"></a>class 文件格式</h3><ul><li>是一种二进制格式的编译后的代码，独立于硬件和操作系统，可由 Java 虚拟机执行，通常（但不一定）存储在文件中，称为<code>class</code>文件格式(如：Simple.class)。文件格式精确地定义了类或接口的<code>class</code>表示，包括诸如字节顺序之类的细节</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Share</title>
      <link href="/2022/01/22/share/"/>
      <url>/2022/01/22/share/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇文章主要的目的是建立好文链接，将所遇见的好文章收录，方便知识集中</p></blockquote><h3 id="那些年搞不懂的高深术语——依赖倒置•控制反转•依赖注入•面向接口编程"><a href="#那些年搞不懂的高深术语——依赖倒置•控制反转•依赖注入•面向接口编程" class="headerlink" title="那些年搞不懂的高深术语——依赖倒置•控制反转•依赖注入•面向接口编程 "></a><a href="https://www.cnblogs.com/aoyeyuyan/p/5495219.html">那些年搞不懂的高深术语——依赖倒置•控制反转•依赖注入•面向接口编程 </a></h3><ul><li>通俗易懂的语言解释内聚、耦合、耦合度等抽象的高深术语，很值得去学习这种文章写法</li><li>在代码中追求高内聚，低耦合。</li></ul><h3 id="C语言编程学习网站"><a href="#C语言编程学习网站" class="headerlink" title="C语言编程学习网站"></a><a href="http://c.biancheng.net/cpp/">C语言编程学习网站</a></h3><ul><li>该网站可以了解到编程更本质的知识点，有种醍醐灌顶的感觉</li></ul>]]></content>
      
      
      <categories>
          
          <category> Share </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Share </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 访问控制修饰符</title>
      <link href="/2022/01/22/javamodifiers/"/>
      <url>/2022/01/22/javamodifiers/</url>
      
        <content type="html"><![CDATA[<blockquote><p>顾名思义，访问控制修饰符就是在面向对象编程过程中，通过使用访问控制修饰符来限制对对象私有属性的访问，可防止对封装数据的未授权访问，有助于保证数据完整性，以达到封装的效果</p></blockquote><h2 id="访问控制修饰符种类"><a href="#访问控制修饰符种类" class="headerlink" title="访问控制修饰符种类"></a>访问控制修饰符种类</h2><ul><li>常见的访问控制修饰符 <strong><code>public</code><strong>、</strong><code>protected</code><strong>、</strong><code>default</code><strong>、</strong><code>private</code></strong></li></ul><h2 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h2><p>  了解各个修饰符的作用域有利于在实际编程中更好的根据具体场景给属性方法添加对应的修饰符，合理地使用访问控制符，可以通过降低类和类之间的耦合性（关联性）来降低整个项目的复杂度，也便于整个项目的开发和维护</p><table><thead><tr><th>访问范围</th><th>private</th><th>default(默认)</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>同一个类</td><td>可访问</td><td>可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>同一包中的其他类</td><td>不可访问</td><td>可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>不同包中的子类</td><td>不可访问</td><td>不可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>不同包中的非子类</td><td>不可访问</td><td>不可访问</td><td>不可访问</td><td>可访问</td></tr></tbody></table><h2 id="各个修饰符的说明"><a href="#各个修饰符的说明" class="headerlink" title="各个修饰符的说明"></a>各个修饰符的说明</h2><h3 id="1-private"><a href="#1-private" class="headerlink" title="1. private"></a>1. private</h3><p><strong>用 private 修饰的类成员，只能被该类自身的方法访问和修改，而不能被任何其他类（包括该类的子类，注意就算是子类也不能访问，在继承那里可以明显感受到这个特性）访问和引用</strong>。因此，private 修饰符具有最高的保护级别。例如，设 PhoneCard 是电话卡类，电话卡都有密码，因此该类有一个密码域，可以把该类的密码域声明为私有成员。</p><h3 id="2-default（默认）"><a href="#2-default（默认）" class="headerlink" title="2. default（默认）"></a>2. default（默认）</h3><p>如果一个类没有访问控制符，说明它具有默认的访问控制特性。<strong>这种默认的访问控制权规定，该类只能被同一个包中的类访问和引用，而不能被其他包中的类使用，<code>即使其他包中有该类的子类</code>。这种访问特性又称为包访问性（package private）</strong>。</p><p>同样，类内的成员如果没有访问控制符，也说明它们具有包访问性，或称为友元（friend）。定义在同一个文件夹中的所有类属于一个包，所以前面的程序要把用户自定义的类放在同一个文件夹中（Java 项目默认的包），以便不加修饰符也能运行。</p><h3 id="3-protected"><a href="#3-protected" class="headerlink" title="3. protected"></a>3. protected</h3><p>用保护访问控制符 protected 修饰的类成员可以被三种类所访问：<strong>该类自身</strong>、<strong>与它在同一个包中的其他类</strong>以及<strong>在其他包中的该类的子类</strong>。使用 protected 修饰符的主要作用，是允许其他包中它的子类来访问父类的特定属性和方法，否则可以使用默认访问控制符。</p><h3 id="4-public"><a href="#4-public" class="headerlink" title="4. public"></a>4. public</h3><p>当一个类被声明为 public 时，它就具有了被其他包中的类访问的可能性，只要包中的其他类在程序中使用 import 语句引入 public 类，就可以访问和引用这个类。</p><p>类中被设定为 public 的方法是这个类对外的接口部分，避免了程序的其他部分直接去操作类内的数据，实际就是数据封装思想的体现。每个 Java 程序的主类都必须是 public 类，也是基于相同的原因。</p><h2 id="修饰符在继承中的使用例子"><a href="#修饰符在继承中的使用例子" class="headerlink" title="修饰符在继承中的使用例子"></a>修饰符在继承中的使用例子</h2><ul><li><p>测试 private 修饰的属性和方法（其他的修饰符测试过程一样，同样验证上面的作用范围是符合的）</p><p>Father Class 如下：</p><pre class=" language-jsp"><code class="language-jsp">public class FatherClass &#123;  private String name;    private void setName(String name)&#123;            this.name = name    &#125;&#125;</code></pre><p>Son Class 如下：</p><pre class=" language-jsp"><code class="language-jsp">public class SonClass extends FatherClass&#123;&#125;</code></pre><p>同个包下的测试类 MainTest 如下：</p><pre class=" language-shell"><code class="language-shell">public class MainTest &#123;    public static void main(String[] args) &#123;                    FatherClass fatherClass = new FatherClass();                        SonClass sonClass = new SonClass();                        //fatherClass.                        //sonClass.    &#125;&#125;</code></pre><ul><li><p>测试分析：</p><p>​    在 MainTest 分别 FatherClass 和 SonClass 的对象，通过 fatherClass.或者 sonClass. (对象引用. ) 获取 name 属性和 setName 方法,都是不可用的</p></li><li><p>测试结果 ：</p><p>​    用 private 修饰的类成员，只能被该类自身的方法访问和修改，而不能被任何其他类（包括该类的子类）访问和引用</p></li></ul></li><li><p>测试在继承关系中代码执行顺序</p><ul><li>目的：在面试中可能会被问到代码执行顺序</li></ul><p>Father Class 如下：</p><pre class=" language-jsp"><code class="language-jsp">package com.example.springbootdemo.spec;public class FatherClass &#123;    //父类构造器    public FatherClass() &#123;        System.out.println("Father Construct");    &#125;    //父类静态代码块    static &#123;        System.out.println("Father static block");    &#125;    //父类成员代码块    &#123;        System.out.println("Father instance block");    &#125;&#125;</code></pre><p>Son Class 如下：</p><pre class=" language-jsp"><code class="language-jsp">package com.example.springbootdemo.spec;public class SonClass extends FatherClass&#123;    //子类构造器    public SonClass() &#123;        System.out.println("Son Construct");    &#125;        //子类静态代码块    static &#123;        System.out.println("Son static block");    &#125;        //子类成员代码块    &#123;        System.out.println("Son instance block");    &#125;&#125;</code></pre><p>同个包下的测试类 MainTest 如下：</p><pre class=" language-jsp"><code class="language-jsp">package com.example.springbootdemo.spec;public class MainTest &#123;    public static void main(String[] args) &#123;        System.out.println("实例化子类");        SonClass sonClass = new SonClass();        System.out.println("实例化父类");        FatherClass fatherClass = new FatherClass();        System.out.println("实例化子类");        SonClass sonClass1 = new SonClass();    &#125;&#125;</code></pre><p>测试输出结果：</p><pre class=" language-shell"><code class="language-shell">Father static blockSon static blockFather instance blockFather ConstructSon instance blockSon Construct实例化父类Father instance blockFather Construct实例化子类Father instance blockFather ConstructSon instance blockSon Construct</code></pre><ul><li><p>测试分析：</p><p>​    分析前先说以下几个默认前提</p><p>​        1、静态代码块：用 staitc 声明，jvm 加载类时执行，仅执行一次<br>​        2、构造代码块：类中直接用{}定义，<strong>每一次</strong>创建对象时执行。<br>​        3、执行顺序优先级：静态块,main(),构造代码块,构造方法。</p><p>​        4、以上均为不带参数构造器，在调用子类构造器时，会默认使用 super 调用父类构造器</p></li></ul><p>​                程序运行时，此时会因为继承关系会先加载 FatherClass 类，因此看到先输出父类静态代码块打印，接着是子类静态代码块。new SonClass() 分配内存，创建对象，因为会默认先调用父类创建对象，所以会看到先输出父类的构造代码块输出和构造器输出，接着就是子类的。第二次直接创建父类对象时，不会再看到静态代码部分输出，因为静态代码块仅执行一次。第三次创建子类对象时，子类的静态代码块也不执行。</p><ul><li><p>测试结果：</p><p>​    创建子类对象时执行顺序：</p><p>​        父类静态代码块 <strong>&gt;</strong> 子类静态代码块 <strong>&gt;</strong> 父类构造代码块 <strong>&gt;</strong> 父类构造器 <strong>&gt;</strong> 子类构造代码块 <strong>&gt;</strong> 子类构造器</p></li></ul></li><li><p>关于更多的代码执行顺序以及深层原因，可参考<a href="https://www.1024sou.com/article/38293.html">【Java】各种代码块的执行顺序</a></p><ul><li><p>基本顺序 ：<code>静态 &gt; main 函数 &gt; 构造代码块 &gt; 构造函数</code> （只需要理解记住该顺序，可根据不同的情况扩展不同的顺序）</p><ul><li><p>当一个类的时候，假设都含有静态成员变量和成员变量时</p><p>静态成员 &gt; 静态代码块 &gt; main 函数 &gt; 成员变量 &gt; 构造代码块 &gt; 构造函数</p></li><li><p>当有继承关系的时候，假设都含有静态成员变量和成员变量时</p><p>父类静态成员 &gt; 父类静态代码块 &gt; 子类静态成员 &gt; 子类静态代码块 &gt; main 函数 &gt; 父类成员变量 &gt; 父类构造代码块 &gt; 父类构造函数 &gt; 子类成员变量 &gt; 子类构造代码块 &gt; 构造函数</p></li><li><p>当父类也有自己的父类时，假设都含有静态成员变量和成员变量时（不管有多少个父类，都是嵌套的）</p><p>父类 B 的父类静态成员 &gt; 父类 B 的父类静态代码块 &gt; 父类 B 静态成员 &gt; 父类 B 静态代码块 &gt; 子类静态成员 &gt; 子类静态代码块 &gt; main 函数 &gt; 父类 B 的父类成员变量 &gt; 父类 B 的父类构造代码块 &gt; 父类 B 的父类构造函数 &gt; 父类成员变量 &gt; 父类构造代码块 &gt; 父类构造函数 &gt; 子类成员变量 &gt; 子类构造代码块 &gt; 构造函数</p></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/11/hello-world/"/>
      <url>/2022/01/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

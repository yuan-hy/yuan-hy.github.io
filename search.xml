<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux 命令积累</title>
      <link href="/2022/01/30/linuxcommand/"/>
      <url>/2022/01/30/linuxcommand/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 虚拟机小知识</title>
      <link href="/2022/01/23/jvm/"/>
      <url>/2022/01/23/jvm/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于阅读 Oracle 官方文档对 JVM 规范的知识积累</p></blockquote><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ul><li><p>Java 虚拟机(简称 <strong>JVM</strong>)是 Java 平台的基石。它是该技术的组成部分，独立于硬件和操作系统、具有轻量编译代码以及保护用户免受恶意程序侵害的能力。</p></li><li><p>Java 虚拟机对 Java 编程语言一无所知，只知道一种特定的二进制格式，即<code>class</code>文件格式。<code>class</code>文件包含 Java 虚拟机指令（或<em>字节码</em>）和符号表，以及其他辅助信息。</p></li><li><p>为了安全起见，Java 虚拟机在 <code>class</code> 文件上的代码强加强大的句法和结构约束。但是，任何具有可以用有效<code>class</code>文件表示的功能的语言都可以由 Java 虚拟机托管(通俗来讲就是一门语言，如果编译后为有效的 <code>class</code> 文件,都可以被 JVM 识别，在 JVM 上运行，例如 groovy 语言)</p></li></ul><h2 id="Java-虚拟机架构"><a href="#Java-虚拟机架构" class="headerlink" title="Java 虚拟机架构"></a>Java 虚拟机架构</h2><p>要正确实现 Java 虚拟机，您只需要能够读取<code>class</code>文件格式并正确执行其中指定的操作即可。不属于 Java 虚拟机规范的实现细节会不必要地限制实现者的创造力。例如，运行时数据区域(<code>run-time data areas</code>)的内存布局、使用的垃圾收集算法(<code>garbage-collection algorithm</code>)以及 Java 虚拟机指令的任何内部优化（例如，将它们转换为机器代码）都由实现者自行决定。</p><h3 id="class-文件格式"><a href="#class-文件格式" class="headerlink" title="class 文件格式"></a>class 文件格式</h3><ul><li>是一种二进制格式的编译后的代码，独立于硬件和操作系统，可由 Java 虚拟机执行，通常（但不一定）存储在文件中，称为<code>class</code>文件格式(如：Simple.class)。文件格式精确地定义了类或接口的<code>class</code>表示，包括诸如字节顺序之类的细节</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好文分享</title>
      <link href="/2022/01/22/share/"/>
      <url>/2022/01/22/share/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇文章主要的目的是建立好文链接，将所遇见的好文章收录，方便知识集中</p></blockquote><ol><li><h3 id="那些年搞不懂的高深术语——依赖倒置•控制反转•依赖注入•面向接口编程"><a href="#那些年搞不懂的高深术语——依赖倒置•控制反转•依赖注入•面向接口编程" class="headerlink" title="那些年搞不懂的高深术语——依赖倒置•控制反转•依赖注入•面向接口编程 "></a><a href="https://www.cnblogs.com/aoyeyuyan/p/5495219.html">那些年搞不懂的高深术语——依赖倒置•控制反转•依赖注入•面向接口编程 </a></h3><ul><li>通俗易懂的语言解释内聚、耦合、耦合度等抽象的高深术语，很值得去学习这种文章写法</li><li>在代码中追求高内聚，低耦合。</li></ul></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> Share </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Share </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 访问控制修饰符</title>
      <link href="/2022/01/22/javamodifiers/"/>
      <url>/2022/01/22/javamodifiers/</url>
      
        <content type="html"><![CDATA[<blockquote><p>顾名思义，访问控制修饰符就是在面向对象编程过程中，通过使用访问控制修饰符来限制对对象私有属性的访问，可防止对封装数据的未授权访问，有助于保证数据完整性，以达到封装的效果</p></blockquote><h2 id="访问控制修饰符种类"><a href="#访问控制修饰符种类" class="headerlink" title="访问控制修饰符种类"></a>访问控制修饰符种类</h2><ul><li>常见的访问控制修饰符 <strong><code>public</code><strong>、</strong><code>protected</code><strong>、</strong><code>default</code><strong>、</strong><code>private</code></strong></li></ul><h2 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h2><p>  了解各个修饰符的作用域有利于在实际编程中更好的根据具体场景给属性方法添加对应的修饰符，合理地使用访问控制符，可以通过降低类和类之间的耦合性（关联性）来降低整个项目的复杂度，也便于整个项目的开发和维护</p><table><thead><tr><th>访问范围</th><th>private</th><th>default(默认)</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>同一个类</td><td>可访问</td><td>可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>同一包中的其他类</td><td>不可访问</td><td>可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>不同包中的子类</td><td>不可访问</td><td>不可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>不同包中的非子类</td><td>不可访问</td><td>不可访问</td><td>不可访问</td><td>可访问</td></tr></tbody></table><h2 id="各个修饰符的说明"><a href="#各个修饰符的说明" class="headerlink" title="各个修饰符的说明"></a>各个修饰符的说明</h2><h3 id="1-private"><a href="#1-private" class="headerlink" title="1. private"></a>1. private</h3><p><strong>用 private 修饰的类成员，只能被该类自身的方法访问和修改，而不能被任何其他类（包括该类的子类，注意就算是子类也不能访问，在继承那里可以明显感受到这个特性）访问和引用</strong>。因此，private 修饰符具有最高的保护级别。例如，设 PhoneCard 是电话卡类，电话卡都有密码，因此该类有一个密码域，可以把该类的密码域声明为私有成员。</p><h3 id="2-default（默认）"><a href="#2-default（默认）" class="headerlink" title="2. default（默认）"></a>2. default（默认）</h3><p>如果一个类没有访问控制符，说明它具有默认的访问控制特性。<strong>这种默认的访问控制权规定，该类只能被同一个包中的类访问和引用，而不能被其他包中的类使用，<code>即使其他包中有该类的子类</code>。这种访问特性又称为包访问性（package private）</strong>。</p><p>同样，类内的成员如果没有访问控制符，也说明它们具有包访问性，或称为友元（friend）。定义在同一个文件夹中的所有类属于一个包，所以前面的程序要把用户自定义的类放在同一个文件夹中（Java 项目默认的包），以便不加修饰符也能运行。</p><h3 id="3-protected"><a href="#3-protected" class="headerlink" title="3. protected"></a>3. protected</h3><p>用保护访问控制符 protected 修饰的类成员可以被三种类所访问：<strong>该类自身</strong>、<strong>与它在同一个包中的其他类</strong>以及<strong>在其他包中的该类的子类</strong>。使用 protected 修饰符的主要作用，是允许其他包中它的子类来访问父类的特定属性和方法，否则可以使用默认访问控制符。</p><h3 id="4-public"><a href="#4-public" class="headerlink" title="4. public"></a>4. public</h3><p>当一个类被声明为 public 时，它就具有了被其他包中的类访问的可能性，只要包中的其他类在程序中使用 import 语句引入 public 类，就可以访问和引用这个类。</p><p>类中被设定为 public 的方法是这个类对外的接口部分，避免了程序的其他部分直接去操作类内的数据，实际就是数据封装思想的体现。每个 Java 程序的主类都必须是 public 类，也是基于相同的原因。</p><h2 id="修饰符在继承中的使用例子"><a href="#修饰符在继承中的使用例子" class="headerlink" title="修饰符在继承中的使用例子"></a>修饰符在继承中的使用例子</h2><ul><li><p>测试 private 修饰的属性和方法（其他的修饰符测试过程一样，同样验证上面的作用范围是符合的）</p><p>Father Class 如下：</p><pre class=" language-jsp"><code class="language-jsp">public class FatherClass &#123;  private String name;    private void setName(String name)&#123;            this.name = name    &#125;&#125;</code></pre><p>Son Class 如下：</p><pre class=" language-jsp"><code class="language-jsp">public class SonClass extends FatherClass&#123;&#125;</code></pre><p>同个包下的测试类 MainTest 如下：</p><pre class=" language-shell"><code class="language-shell">public class MainTest &#123;    public static void main(String[] args) &#123;                    FatherClass fatherClass = new FatherClass();                        SonClass sonClass = new SonClass();                        //fatherClass.                        //sonClass.    &#125;&#125;</code></pre><ul><li><p>测试分析：</p><p>​    在 MainTest 分别 FatherClass 和 SonClass 的对象，通过 fatherClass.或者 sonClass. (对象引用. ) 获取 name 属性和 setName 方法,都是不可用的</p></li><li><p>测试结果 ：</p><p>​    用 private 修饰的类成员，只能被该类自身的方法访问和修改，而不能被任何其他类（包括该类的子类）访问和引用</p></li></ul></li><li><p>测试在继承关系中代码执行顺序</p><ul><li>目的：在面试中可能会被问到代码执行顺序</li></ul><p>Father Class 如下：</p><pre class=" language-jsp"><code class="language-jsp">package com.example.springbootdemo.spec;public class FatherClass &#123;    //父类构造器    public FatherClass() &#123;        System.out.println("Father Construct");    &#125;    //父类静态代码块    static &#123;        System.out.println("Father static block");    &#125;    //父类成员代码块    &#123;        System.out.println("Father instance block");    &#125;&#125;</code></pre><p>Son Class 如下：</p><pre class=" language-jsp"><code class="language-jsp">package com.example.springbootdemo.spec;public class SonClass extends FatherClass&#123;    //子类构造器    public SonClass() &#123;        System.out.println("Son Construct");    &#125;        //子类静态代码块    static &#123;        System.out.println("Son static block");    &#125;        //子类成员代码块    &#123;        System.out.println("Son instance block");    &#125;&#125;</code></pre><p>同个包下的测试类 MainTest 如下：</p><pre class=" language-jsp"><code class="language-jsp">package com.example.springbootdemo.spec;public class MainTest &#123;    public static void main(String[] args) &#123;        System.out.println("实例化子类");        SonClass sonClass = new SonClass();        System.out.println("实例化父类");        FatherClass fatherClass = new FatherClass();        System.out.println("实例化子类");        SonClass sonClass1 = new SonClass();    &#125;&#125;</code></pre><p>测试输出结果：</p><pre class=" language-shell"><code class="language-shell">Father static blockSon static blockFather instance blockFather ConstructSon instance blockSon Construct实例化父类Father instance blockFather Construct实例化子类Father instance blockFather ConstructSon instance blockSon Construct</code></pre><ul><li><p>测试分析：</p><p>​    分析前先说以下几个默认前提</p><p>​        1、静态代码块：用 staitc 声明，jvm 加载类时执行，仅执行一次<br>​        2、构造代码块：类中直接用{}定义，<strong>每一次</strong>创建对象时执行。<br>​        3、执行顺序优先级：静态块,main(),构造代码块,构造方法。</p><p>​        4、以上均为不带参数构造器，在调用子类构造器时，会默认使用 super 调用父类构造器</p></li></ul><p>​                程序运行时，此时会因为继承关系会先加载 FatherClass 类，因此看到先输出父类静态代码块打印，接着是子类静态代码块。new SonClass() 分配内存，创建对象，因为会默认先调用父类创建对象，所以会看到先输出父类的构造代码块输出和构造器输出，接着就是子类的。第二次直接创建父类对象时，不会再看到静态代码部分输出，因为静态代码块仅执行一次。第三次创建子类对象时，子类的静态代码块也不执行。</p><ul><li><p>测试结果：</p><p>​    创建子类对象时执行顺序：</p><p>​        父类静态代码块 <strong>&gt;</strong> 子类静态代码块 <strong>&gt;</strong> 父类构造代码块 <strong>&gt;</strong> 父类构造器 <strong>&gt;</strong> 子类构造代码块 <strong>&gt;</strong> 子类构造器</p></li></ul></li><li><p>关于更多的代码执行顺序以及深层原因，可参考<a href="https://www.1024sou.com/article/38293.html">【Java】各种代码块的执行顺序</a></p><ul><li><p>基本顺序 ：<code>静态 &gt; main 函数 &gt; 构造代码块 &gt; 构造函数</code> （只需要理解记住该顺序，可根据不同的情况扩展不同的顺序）</p><ul><li><p>当一个类的时候，假设都含有静态成员变量和成员变量时</p><p>静态成员 &gt; 静态代码块 &gt; main 函数 &gt; 成员变量 &gt; 构造代码块 &gt; 构造函数</p></li><li><p>当有继承关系的时候，假设都含有静态成员变量和成员变量时</p><p>父类静态成员 &gt; 父类静态代码块 &gt; 子类静态成员 &gt; 子类静态代码块 &gt; main 函数 &gt; 父类成员变量 &gt; 父类构造代码块 &gt; 父类构造函数 &gt; 子类成员变量 &gt; 子类构造代码块 &gt; 构造函数</p></li><li><p>当父类也有自己的父类时，假设都含有静态成员变量和成员变量时（不管有多少个父类，都是嵌套的）</p><p>父类 B 的父类静态成员 &gt; 父类 B 的父类静态代码块 &gt; 父类 B 静态成员 &gt; 父类 B 静态代码块 &gt; 子类静态成员 &gt; 子类静态代码块 &gt; main 函数 &gt; 父类 B 的父类成员变量 &gt; 父类 B 的父类构造代码块 &gt; 父类 B 的父类构造函数 &gt; 父类成员变量 &gt; 父类构造代码块 &gt; 父类构造函数 &gt; 子类成员变量 &gt; 子类构造代码块 &gt; 构造函数</p></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/11/hello-world/"/>
      <url>/2022/01/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
